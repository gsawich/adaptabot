# Early trading algorithm to test strategies
import time
import datetime
import connections


def main(Q, MARG, PAIR, LAST):
    q=Q
    margin = MARG
    period = 10
    pair = PAIR
    prices = []
    emaprices = []
    currentMovingAverage = 0;
    currentEMA = 0;
    lengthOfMA = 60
    lengthofEMA = 120
    timespan = 60*60*24
    startTime = True
    endTime = int(time.time())
    historicalData = False
    tradePlaced = False
    typeOfTrade = False
    dataDate = ""
    orderNumber = ""
    lastTrade = LAST

    conn = connections.bittrex

    while True:
        if (startTime and historicalData):
            nextDataPoint = historicalData.pop(0)
            lastPairPrice = nextDataPoint['weightedAverage']
            dataDate = datetime.datetime.fromtimestamp(int(nextDataPoint['date'])).strftime('%Y-%m-%d %H:%M:%S')
        #elif (startTime and not historicalData):
        #    exit()
        else:
            currentValues = conn.get_ticker(pair)
            print(currentValues['result'])
            lastPairPrice = float(currentValues['result']['Last'])
            dataDate = datetime.datetime.now()

        if ((len(prices) > 0)):
            currentMovingAverage = sum(prices) / float(len(prices))
            currentEMA = sum(emaprices) / float(len(emaprices))
            previousPrice = float(prices[-1])
            if (not tradePlaced and (not historicalData)):
                startTime = False
                if ((lastPairPrice > currentMovingAverage) and (lastPairPrice > currentEMA) and (lastPairPrice < previousPrice) and (lastPairPrice > (lastTrade*margin))):
                    print("SELL ORDER")
                    orderNumber = conn.sell_limit(pair, quantity=q, rate=lastPairPrice)
                    print(orderNumber)
                    tradePlaced = True
                    typeOfTrade = "short"
                    lastTrade = lastPairPrice
                elif ((lastPairPrice < currentMovingAverage) and (lastPairPrice < currentEMA) and (lastPairPrice > previousPrice) and (lastPairPrice < (lastTrade/margin))):
                    print("BUY ORDER")
                    orderNumber = conn.buy_limit(pair, quantity=q, rate=lastPairPrice)
                    print(orderNumber)
                    tradePlaced = True
                    typeOfTrade = "long"
                    lastTrade = lastPairPrice
            elif (typeOfTrade == "short"):
                if (lastPairPrice < currentMovingAverage and lastPairPrice < currentEMA/margin and orderNumber['result']['uuid'] != None):
                    print("EXIT TRADE")
                    conn.cancel(orderNumber['result']['uuid'])
                    tradePlaced = False
                    typeOfTrade = False
            elif (typeOfTrade == "long"):
                if (lastPairPrice > currentMovingAverage and lastPairPrice > currentEMA*margin and orderNumber['result']['uuid'] != None):
                    print("EXIT TRADE")
                    conn.cancel(orderNumber['result']['uuid'])
                    tradePlaced = False
                    typeOfTrade = False
        else:
            previousPrice = 0

        print(
            "%s %s: %s Moving Average: %s EMA: %s" % (dataDate, pair, lastPairPrice, currentMovingAverage, currentEMA))

        prices.append(float(lastPairPrice))
        prices = prices[-lengthOfMA:]

        emaprices.append(float(lastPairPrice))
        emaprices = emaprices[-lengthofEMA:]
        if (not startTime):
            time.sleep(int(period))

main(10, 1.0125, "BTC-OMG", 0.0011)
